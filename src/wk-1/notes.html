<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>notes.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1 id="notes-on-week-1">Notes on Week 1</h1>
<h1 id="what-is-learnt">What is learnt</h1>
<ul>
<li>Do the same as in Part A but in a dynamically typed language - Racket</li>
<li>Zero argument functions that lead to understanding the concept of streams.</li>
<li>Macros - extend the syntax of a programming language</li>
</ul>
<h2 id="module-two">Module Two</h2>
<ul>
<li>Implement an interpreter</li>
<li>Static vs Dynamic Typing</li>
</ul>
<h1 id="lazy-evaluation">Lazy Evaluation</h1>
<p>Evaluation of arguments of a function are evaluated before the function body is evaluated, which is <code>pass by value</code>. It is different for evaluation of <code>if</code> expression, the evaluation of if expression and the else expression are evaluated based on the evaluation of the test expression.</p>
<p>How variables are looked up in an environment - the bindings - is a fundamental feature of a programming language.</p>
<p>Understanding the semantics of evaluation of subexpressions of a programming language is paramount. For example, in racket, given (e1 e2 … en), e2 till en are evaluated only once before the function body is evaluated, and give the function (lambda (…) …), the body is evaluated only when the function is called.</p>
<p>Therefore in the code snippet below,</p>
<pre><code>(define (my-if-bad e1 e2 e3) (if e1 e2 e3))

(define (factorial-wrong x)
  (my-if-bad (= x 0)
             1
             (* x (factorial-wrong (- x 1)))))</code></pre>
<p>the three arguments to the function <code>factorial-wrong</code> are evaluated and therefore <code>factorial-wrong</code> never terminates. The branching in a</p>
<p>The evaluation of expressions in an <code>if</code> is different. <code>(if e1 e2 e3)</code>, based on the result of evaluation of <code>e1</code>, either <code>e2</code> or <code>e3</code> is evaluated.</p>
<p>To overcome the evaluation of the arguments, the property of functions - body evaluated only upon function call - is exploited. Therefore, to the above if, the arguments are passed as <code>0</code> argument functions, called <code>thunks</code>.</p>
<pre><code>(define (my-if x y z) (if x (y) (z)))

(define (factorial x)
  (my-if (= x 0)
         (λ () 1)
         (λ () (* x (factorial (- x 1))))))</code></pre>
<h1 id="delayed-evaluation">Delayed Evaluation</h1>
<ol type="1">
<li><p>All the arguments are evaluated before the function body is evluated. Use thunks to circumvent this.</p>
<pre><code>(define (my-if-bad e1 e2 e3) (if e1 e2 e3))
(define (my-if e1 e2-th e3-th) (if e1 (e2-th) (e3-th)))</code></pre>
<p>In above code snippet, in <code>my-if-bad</code> e2 and e3 are evaluated before the function body though in the body, based upon the evaluation of e1, either e2 or e3 is evaluated. This can lead to undesired consequences of non termination in a recursive call where the base case would never be reached, due to the evaluation of both e2 and e3.</p>
<p>This is rectified in <code>my-if</code>, where e2 and e3 are thunked to create e2-th and e3-th where e2 and e3 are wrapped in <code>0</code> argument functions.</p>
<pre><code>(define e2-th (λ () e2)
(define e3-th (λ () e3)</code></pre></li>
<li><p>Using thunks design promises</p>
<p>The need for promises is to avaoid repeated evaluations. This is achieved by storing the value of the first evaluation and returning upon further evaluations. The <code>delay</code> function returns a <code>promise</code> while the <code>force</code> function evalutes the function stored in the <code>promise</code> based upon the flag set in the <code>promise</code>. The function stored in the promise is always a thunk.</p>
<pre><code>(define (my-mult-t x y-thunk)
  (cond [(= x 0) 0]
     [(= x 1) (y-thunk)]
     [#t (+ (y-thunk) (my-mult-t (- x 1) y-thunk))]))

(define (my-delay f)
  n(mcons #f f))

 (define (my-force th)
   (cond [(mcar th) (mcdr th)]
     [#t (begin
           (set-mcar! th #t)
           (set-mcdr! th ((mcdr th)))
           (mcdr th))]))</code></pre>
<p>In the above code, the second argumet to the function <code>my-mult</code> is a thunk. Therefore, the <code>force</code> is wrapped in a thunk and passed to it. The argument to the <code>force</code> function is the output of the <code>delay</code> which is a promise.</p>
<pre><code>(my-mult-t 2
      (let
          ([x (my-delay (λ () 3))])
          (λ () (my-force x))))</code></pre>
<p>This is generalised by the following implementaion</p>
<pre><code>(define (my-mult-p x y-promise)
 (cond [(= x 0) 0]
     [(= x 1) (my-force y-promise)]
     [#t (+ (my-force y-promise) (my-mult-p (- x 1) y-promise))]))

(my-mult-p 2 (my-delay (λ () 3)))
</code></pre>
<p>There is a need to obeserve the follwing facts:</p>
<ol type="1">
<li>The second argument to <code>delay</code> is always a thunk.</li>
<li>The second argument to <code>mult</code> is also always a thunk.</li>
</ol></li>
</ol>

</body>
</html>
